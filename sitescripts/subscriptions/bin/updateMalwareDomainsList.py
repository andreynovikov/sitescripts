# coding: utf-8

# This file is part of the Adblock Plus web scripts,
# Copyright (C) 2006-2013 Eyeo GmbH
#
# Adblock Plus is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 3 as
# published by the Free Software Foundation.
#
# Adblock Plus is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Adblock Plus.  If not, see <http://www.gnu.org/licenses/>.

import os, subprocess, codecs, urllib, zipfile, tempfile, shutil
from StringIO import StringIO
from sitescripts.utils import get_config, setupStderr

if __name__ == '__main__':
  setupStderr()

  repository = get_config().get('subscriptionDownloads', 'malwaredomains_repository')
  tempdir = tempfile.mkdtemp(prefix='malwaredomains')
  try:
    subprocess.Popen(['hg', '-q', 'clone',  '-U', repository, tempdir]).communicate()
    subprocess.Popen(['hg', '-q', 'up', '-R', tempdir, '-r', 'default']).communicate()

    path = os.path.join(tempdir, 'malwaredomains_full.txt')
    file = codecs.open(path, 'wb', encoding='utf-8')

    print >>file, '''[Adblock Plus 1.1]
! This is a list of malware domains generated from malwaredomains.com data.
! Homepage: http://malwaredomains.com/?page_id=2
! Last modified: %timestamp%
! Expires: 1d
!'''

    data = urllib.urlopen('http://mirror3.malwaredomains.com/files/justdomains.zip').read()
    zip = zipfile.ZipFile(StringIO(data), 'r')
    info = zip.infolist()[0]
    for line in str(zip.read(info.filename)).splitlines():
      if not line:
        continue
      print >>file, '||%s^' % line.strip().decode('iso-8859-1')
    file.close();

    subprocess.Popen(['hg', '-q', 'commit', '-R', tempdir, '-A', '-u', 'hgbot', '-m', 'Updated malwaredomains.com data']).communicate()
    subprocess.Popen(['hg', '-q', 'push', '-R', tempdir]).communicate()
  finally:
    shutil.rmtree(tempdir, ignore_errors=True)
